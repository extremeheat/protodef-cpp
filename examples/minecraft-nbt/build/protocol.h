// DO NOT EDIT THIS FILE:
// This file was automatically generated by protodef-cpp
#include <string>
#include <vector>
#include <optional>
#include <memory>
#include "stream.h"
#ifndef DBG_PRINT
#define DBG_PRINT(...)
#endif
#define WRITE_OR_BAIL(fn, val) if (!stream.fn(val)) { DBG_PRINT("%s:%d: %s: write FAIL\n", __func__, __LINE__, #fn); return false; }; DBG_PRINT("%s:%d: %s: written, stream now at %d\n", __func__, __LINE__, #fn, stream.writeIndex);
#define READ_OR_BAIL(fn, val) if (!stream.fn(val)) { DBG_PRINT("%s:%d: %s: read FAIL\n", __func__, __LINE__, #fn); return false; } DBG_PRINT("%s:%d: %s: read, stream now at %d\n", __func__, __LINE__, #fn, stream.readIndex);
#define EXPECT_OR_BAIL(val) if (!val) { DBG_PRINT("%s:%d: bad assert %s\n", __func__, __LINE__, #val); return false; }
#define PDEF_SIZE_DBG DBG_PRINT("%s: sized at %lld\n", __func__, len);
#define PDEF_JSON_putString_OR_BAIL(J, V) stream.writeString("\"" #J "\":\""); stream.writeString(V); EXPECT_OR_BAIL(stream.writeString("\","));
#define PDEF_JSON_putNumber_OR_BAIL(J, V) stream.writeString("\"" #J "\":"); stream.writeDoubleInAsciiDigits((double)V); EXPECT_OR_BAIL(stream.writeString(","));
#define PDEF_JSON_putUInt_OR_BAIL(J, V) stream.writeString("\"" #J "\":"); stream.writeUnsignedLongInAsciiDigits((uint64_t)V); EXPECT_OR_BAIL(stream.writeString(","));
#define PDEF_JSON_putInt_OR_BAIL(J, V) stream.writeString("\"" #J "\":"); stream.writeSignedLongInAsciiDigits((int64_t)V); EXPECT_OR_BAIL(stream.writeString(","));
#define PDEF_JSON_putBuffer_OR_BAIL(J, V) stream.writeString("\"" #J "\":\""); stream.writeBuffer(V); EXPECT_OR_BAIL(stream.writeString("\","));
#define PDEF_JSON_putStringAnon_OR_BAIL(V) stream.writeUByte('"'); stream.writeString(V); EXPECT_OR_BAIL(stream.writeString("\","));
#define PDEF_JSON_putNumberAnon_OR_BAIL(V) stream.writeDoubleInAsciiDigits(V); EXPECT_OR_BAIL(stream.writeString(","));
#define PDEF_JSON_putIntAnon_OR_BAIL(V) stream.writeSignedLongInAsciiDigits(V); EXPECT_OR_BAIL(stream.writeString(","));
#define PDEF_JSON_putBufferAnon_OR_BAIL(V) stream.writeUByte('"'); stream.writeBuffer(V); EXPECT_OR_BAIL(stream.writeString("\","));
#define PDEF_JSON_putStartArr_OR_BAIL(J) EXPECT_OR_BAIL(stream.writeString("\"" #J "\":["));
#define PDEF_JSON_putEndArr_OR_BAIL stream.jsonPopIfWroteTrailingComma(); EXPECT_OR_BAIL(stream.writeString("],"));
#define PDEF_JSON_putStartObj_OR_BAIL(J) EXPECT_OR_BAIL(stream.writeString("\"" #J "\":{"));
#define PDEF_JSON_putEndObj_OR_BAIL stream.jsonPopIfWroteTrailingComma(); EXPECT_OR_BAIL(stream.writeString("},"));
#define PDEF_JSON_putToken_OR_BAIL(V) EXPECT_OR_BAIL(stream.writeString(V)); 
#define PDEF_JSON_putField_OR_BAIL(J) EXPECT_OR_BAIL(stream.writeString("\"" #J "\":"));
#define PDEF_JSON_FINISH_WRITING stream.jsonPopIfWroteTrailingComma();
namespace pdef::proto {

struct list;
struct nbt;
// void is built in
// container is built in
// i8 is built in
// switch is built in
// compound is built in
// i16 is built in
// u16 is built in
// i32 is built in
// i64 is built in
// f32 is built in
// f64 is built in
// pstring is built in
  struct list {
    enum class Type : int8_t {
      End = 0,
      Byte = 1,
      Short = 2,
      Int = 3,
      Long = 4,
      Float = 5,
      Double = 6,
      ByteArray = 7,
      String = 8,
      List = 9,
      Compound = 10,
      IntArray = 11,
      LongArray = 12,
    };
    Type type; /*3.2*/
    std::vector<int8_t /*0.0*/> value_i8_array; /*3.0*/
    std::vector<int16_t /*0.0*/> value_i16_array; /*3.0*/
    std::vector<int32_t /*0.0*/> value_i32_array; /*3.0*/
    std::vector<int64_t /*0.0*/> value_i64_array; /*3.0*/
    std::vector<float /*0.0*/> value_f32_array; /*3.0*/
    std::vector<double /*0.0*/> value_f64_array; /*3.0*/
    std::vector<std::vector<int8_t /*0.0*/> /*3.0*/> value_byteArray_array; /*3.0*/
    std::vector<std::string /*6.0*/> value_shortString_array; /*3.0*/
    std::vector<pdef::proto::list /*4.0*/> value_list_array; /*3.0*/
    std::vector<std::vector<pdef::proto::nbt> /*6.0*/> value_compound_array; /*3.0*/
    std::vector<std::vector<int32_t /*0.0*/> /*3.0*/> value_intArray_array; /*3.0*/
    std::vector<std::vector<int64_t /*0.0*/> /*3.0*/> value_longArray_array; /*3.0*/
  };
  enum class nbtMapper : int8_t {
    End = 0,
    Byte = 1,
    Short = 2,
    Int = 3,
    Long = 4,
    Float = 5,
    Double = 6,
    ByteArray = 7,
    String = 8,
    List = 9,
    Compound = 10,
    IntArray = 11,
    LongArray = 12,
  };
  struct nbt {
    enum class Type : int8_t {
      End = 0,
      Byte = 1,
      Short = 2,
      Int = 3,
      Long = 4,
      Float = 5,
      Double = 6,
      ByteArray = 7,
      String = 8,
      List = 9,
      Compound = 10,
      IntArray = 11,
      LongArray = 12,
    };
    Type type; /*3.2*/
    std::string name; /*6.0*/
    int8_t value_i8; /*0.0*/
    int16_t value_i16; /*0.0*/
    int32_t value_i32; /*0.0*/
    int64_t value_i64; /*0.0*/
    float value_f32; /*0.0*/
    double value_f64; /*0.0*/
    std::vector<int8_t /*0.0*/> value_byteArray; /*3.0*/
    std::string value_shortString; /*6.0*/
    pdef::Optional<pdef::proto::list> value_list; /*4.0*/
    std::vector<pdef::proto::nbt> value_compound; /*6.0*/
    std::vector<int32_t /*0.0*/> value_intArray; /*3.0*/
    std::vector<int64_t /*0.0*/> value_longArray; /*3.0*/
  };
}

namespace pdef::proto::size {
size_t list(pdef::Stream &stream, const pdef::proto::list &obj);
size_t nbt(pdef::Stream &stream, const pdef::proto::nbt &obj);
  size_t list(pdef::Stream &stream, const pdef::proto::list &obj) {
    size_t len = 0;
    const pdef::proto::list::Type &V_type = obj.type; /*0.3*/
    len += 1; /*type^: i8*/ /*7.0*/
    if (V_type == pdef::proto::list::Type::End) { /*8.5*/
    }
    else if (V_type == pdef::proto::list::Type::Byte) { /*8.5*/
      len += 4; /*1.3*/
      for (const auto &v3 : obj.value_i8_array) { /*3.2*/
        len += 1; /*0.2*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Short) { /*8.5*/
      len += 4; /*1.3*/
      for (const auto &v3 : obj.value_i16_array) { /*3.2*/
        len += 2; /*0.2*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Int) { /*8.5*/
      len += 4; /*1.3*/
      for (const auto &v3 : obj.value_i32_array) { /*3.2*/
        len += 4; /*0.2*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Long) { /*8.5*/
      len += 4; /*1.3*/
      for (const auto &v3 : obj.value_i64_array) { /*3.2*/
        len += 8; /*0.2*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Float) { /*8.5*/
      len += 4; /*1.3*/
      for (const auto &v3 : obj.value_f32_array) { /*3.2*/
        len += 4; /*0.2*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Double) { /*8.5*/
      len += 4; /*1.3*/
      for (const auto &v3 : obj.value_f64_array) { /*3.2*/
        len += 8; /*0.2*/
      }
    }
    else if (V_type == pdef::proto::list::Type::ByteArray) { /*8.5*/
      len += 4; /*1.3*/
      for (const auto &v3 : obj.value_byteArray_array) { /*3.2*/
        len += 4; /*1.3*/
        for (const auto &v4 : v3) { /*3.2*/
          len += 1; /*0.2*/
        }
      }
    }
    else if (V_type == pdef::proto::list::Type::String) { /*8.5*/
      len += 4; /*1.3*/
      for (const auto &v3 : obj.value_shortString_array) { /*3.2*/
        len += 2;
        len += v3.length(); /*: pstring*/ /*4.1*/
      }
    }
    else if (V_type == pdef::proto::list::Type::List) { /*8.5*/
      len += 4; /*1.3*/
      for (const auto &v3 : obj.value_list_array) { /*3.2*/
        size_t len_0 = pdef::proto::size::list(stream, v3); EXPECT_OR_BAIL(len_0); len += len_0; /**/ /*4.4*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Compound) { /*8.5*/
      len += 4; /*1.3*/
      for (const auto &v3 : obj.value_compound_array) { /*3.2*/
        size_t _size = 0;
        for (auto& _item : v3) {
        _size += pdef::proto::size::nbt(stream, _item);
        }
        _size += 1; // 0 tag
        len += _size; /*: compound*/ /*4.1*/
      }
    }
    else if (V_type == pdef::proto::list::Type::IntArray) { /*8.5*/
      len += 4; /*1.3*/
      for (const auto &v3 : obj.value_intArray_array) { /*3.2*/
        len += 4; /*1.3*/
        for (const auto &v4 : v3) { /*3.2*/
          len += 4; /*0.2*/
        }
      }
    }
    else if (V_type == pdef::proto::list::Type::LongArray) { /*8.5*/
      len += 4; /*1.3*/
      for (const auto &v3 : obj.value_longArray_array) { /*3.2*/
        len += 4; /*1.3*/
        for (const auto &v4 : v3) { /*3.2*/
          len += 8; /*0.2*/
        }
      }
    }
    PDEF_SIZE_DBG; return len;
  }
  size_t nbt(pdef::Stream &stream, const pdef::proto::nbt &obj) {
    size_t len = 0;
    const pdef::proto::nbt::Type &V_type = obj.type; /*0.3*/
    len += 1; /*type^: i8*/ /*7.0*/
    len += 2;
    len += obj.name.length(); /*name: pstring*/ /*4.1*/
    if (V_type == pdef::proto::nbt::Type::End) { /*8.5*/
    }
    else if (V_type == pdef::proto::nbt::Type::Byte) { /*8.5*/
      len += 1; /*0.2*/
    }
    else if (V_type == pdef::proto::nbt::Type::Short) { /*8.5*/
      len += 2; /*0.2*/
    }
    else if (V_type == pdef::proto::nbt::Type::Int) { /*8.5*/
      len += 4; /*0.2*/
    }
    else if (V_type == pdef::proto::nbt::Type::Long) { /*8.5*/
      len += 8; /*0.2*/
    }
    else if (V_type == pdef::proto::nbt::Type::Float) { /*8.5*/
      len += 4; /*0.2*/
    }
    else if (V_type == pdef::proto::nbt::Type::Double) { /*8.5*/
      len += 8; /*0.2*/
    }
    else if (V_type == pdef::proto::nbt::Type::ByteArray) { /*8.5*/
      len += 4; /*1.3*/
      for (const auto &v3 : obj.value_byteArray) { /*3.2*/
        len += 1; /*0.2*/
      }
    }
    else if (V_type == pdef::proto::nbt::Type::String) { /*8.5*/
      len += 2;
      len += obj.value_shortString.length(); /*value: pstring*/ /*4.1*/
    }
    else if (V_type == pdef::proto::nbt::Type::List) { /*8.5*/
      EXPECT_OR_BAIL(obj.value_list); size_t len_1 = pdef::proto::size::list(stream, *obj.value_list); EXPECT_OR_BAIL(len_1); len += len_1; /*value_list*/ /*4.4*/
    }
    else if (V_type == pdef::proto::nbt::Type::Compound) { /*8.5*/
      size_t value_compound_size = 0;
      for (auto& value_compound_item : obj.value_compound) {
      value_compound_size += pdef::proto::size::nbt(stream, value_compound_item);
      }
      value_compound_size += 1; // 0 tag
      len += value_compound_size; /*value: compound*/ /*4.1*/
    }
    else if (V_type == pdef::proto::nbt::Type::IntArray) { /*8.5*/
      len += 4; /*1.3*/
      for (const auto &v3 : obj.value_intArray) { /*3.2*/
        len += 4; /*0.2*/
      }
    }
    else if (V_type == pdef::proto::nbt::Type::LongArray) { /*8.5*/
      len += 4; /*1.3*/
      for (const auto &v3 : obj.value_longArray) { /*3.2*/
        len += 8; /*0.2*/
      }
    }
    PDEF_SIZE_DBG; return len;
  }
}

namespace pdef::proto::encode {
bool list(pdef::Stream &stream, const pdef::proto::list &obj, bool allocate);
bool nbt(pdef::Stream &stream, const pdef::proto::nbt &obj, bool allocate);
  bool list(pdef::Stream &stream, const pdef::proto::list &obj, bool allocate = true) {
    if (allocate) { auto writeSize = pdef::proto::size::list(stream, obj); if (!writeSize) return false; stream.reserve(writeSize); }
    const pdef::proto::list::Type &V_type = obj.type; /*0.3*/
    WRITE_OR_BAIL(writeByte, (int8_t)(int8_t&)obj.type); /*7.1*/
    if (V_type == pdef::proto::list::Type::End) { /*8.5*/
    }
    else if (V_type == pdef::proto::list::Type::Byte) { /*8.5*/
      WRITE_OR_BAIL(writeIntBE, (int32_t)obj.value_i8_array.size()); /*1.4*/
      for (const auto &v3 : obj.value_i8_array) { /*3.1*/
        WRITE_OR_BAIL(writeByte, (int8_t)v3); /*0.4*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Short) { /*8.5*/
      WRITE_OR_BAIL(writeIntBE, (int32_t)obj.value_i16_array.size()); /*1.4*/
      for (const auto &v3 : obj.value_i16_array) { /*3.1*/
        WRITE_OR_BAIL(writeShortBE, (int16_t)v3); /*0.4*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Int) { /*8.5*/
      WRITE_OR_BAIL(writeIntBE, (int32_t)obj.value_i32_array.size()); /*1.4*/
      for (const auto &v3 : obj.value_i32_array) { /*3.1*/
        WRITE_OR_BAIL(writeIntBE, (int32_t)v3); /*0.4*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Long) { /*8.5*/
      WRITE_OR_BAIL(writeIntBE, (int32_t)obj.value_i64_array.size()); /*1.4*/
      for (const auto &v3 : obj.value_i64_array) { /*3.1*/
        WRITE_OR_BAIL(writeLongBE, (int64_t)v3); /*0.4*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Float) { /*8.5*/
      WRITE_OR_BAIL(writeIntBE, (int32_t)obj.value_f32_array.size()); /*1.4*/
      for (const auto &v3 : obj.value_f32_array) { /*3.1*/
        WRITE_OR_BAIL(writeFloatBE, (float)v3); /*0.4*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Double) { /*8.5*/
      WRITE_OR_BAIL(writeIntBE, (int32_t)obj.value_f64_array.size()); /*1.4*/
      for (const auto &v3 : obj.value_f64_array) { /*3.1*/
        WRITE_OR_BAIL(writeDoubleBE, (double)v3); /*0.4*/
      }
    }
    else if (V_type == pdef::proto::list::Type::ByteArray) { /*8.5*/
      WRITE_OR_BAIL(writeIntBE, (int32_t)obj.value_byteArray_array.size()); /*1.4*/
      for (const auto &v3 : obj.value_byteArray_array) { /*3.1*/
        WRITE_OR_BAIL(writeIntBE, (int32_t)v3.size()); /*1.4*/
        for (const auto &v4 : v3) { /*3.1*/
          WRITE_OR_BAIL(writeByte, (int8_t)v4); /*0.4*/
        }
      }
    }
    else if (V_type == pdef::proto::list::Type::String) { /*8.5*/
      WRITE_OR_BAIL(writeIntBE, (int32_t)obj.value_shortString_array.size()); /*1.4*/
      for (const auto &v3 : obj.value_shortString_array) { /*3.1*/
        WRITE_OR_BAIL(writeUShortBE, (uint16_t)v3.length());
        WRITE_OR_BAIL(writeString, v3); /*: pstring*/ /*4.2*/
      }
    }
    else if (V_type == pdef::proto::list::Type::List) { /*8.5*/
      WRITE_OR_BAIL(writeIntBE, (int32_t)obj.value_list_array.size()); /*1.4*/
      for (const auto &v3 : obj.value_list_array) { /*3.1*/
        pdef::proto::encode::list(stream, v3); /*list*/ /*4.5*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Compound) { /*8.5*/
      WRITE_OR_BAIL(writeIntBE, (int32_t)obj.value_compound_array.size()); /*1.4*/
      for (const auto &v3 : obj.value_compound_array) { /*3.1*/
        for (auto& _item : v3) {
        pdef::proto::encode::nbt(stream, _item, false);
        }
        stream.writeByte(0); /*: compound*/ /*4.2*/
      }
    }
    else if (V_type == pdef::proto::list::Type::IntArray) { /*8.5*/
      WRITE_OR_BAIL(writeIntBE, (int32_t)obj.value_intArray_array.size()); /*1.4*/
      for (const auto &v3 : obj.value_intArray_array) { /*3.1*/
        WRITE_OR_BAIL(writeIntBE, (int32_t)v3.size()); /*1.4*/
        for (const auto &v4 : v3) { /*3.1*/
          WRITE_OR_BAIL(writeIntBE, (int32_t)v4); /*0.4*/
        }
      }
    }
    else if (V_type == pdef::proto::list::Type::LongArray) { /*8.5*/
      WRITE_OR_BAIL(writeIntBE, (int32_t)obj.value_longArray_array.size()); /*1.4*/
      for (const auto &v3 : obj.value_longArray_array) { /*3.1*/
        WRITE_OR_BAIL(writeIntBE, (int32_t)v3.size()); /*1.4*/
        for (const auto &v4 : v3) { /*3.1*/
          WRITE_OR_BAIL(writeLongBE, (int64_t)v4); /*0.4*/
        }
      }
    }
    return true;
  }
  bool nbt(pdef::Stream &stream, const pdef::proto::nbt &obj, bool allocate = true) {
    if (allocate) { auto writeSize = pdef::proto::size::nbt(stream, obj); if (!writeSize) return false; stream.reserve(writeSize); }
    const pdef::proto::nbt::Type &V_type = obj.type; /*0.3*/
    WRITE_OR_BAIL(writeByte, (int8_t)(int8_t&)obj.type); /*7.1*/
    WRITE_OR_BAIL(writeUShortBE, (uint16_t)obj.name.length());
    WRITE_OR_BAIL(writeString, obj.name); /*name: pstring*/ /*4.2*/
    if (V_type == pdef::proto::nbt::Type::End) { /*8.5*/
    }
    else if (V_type == pdef::proto::nbt::Type::Byte) { /*8.5*/
      WRITE_OR_BAIL(writeByte, (int8_t)obj.value_i8); /*0.4*/
    }
    else if (V_type == pdef::proto::nbt::Type::Short) { /*8.5*/
      WRITE_OR_BAIL(writeShortBE, (int16_t)obj.value_i16); /*0.4*/
    }
    else if (V_type == pdef::proto::nbt::Type::Int) { /*8.5*/
      WRITE_OR_BAIL(writeIntBE, (int32_t)obj.value_i32); /*0.4*/
    }
    else if (V_type == pdef::proto::nbt::Type::Long) { /*8.5*/
      WRITE_OR_BAIL(writeLongBE, (int64_t)obj.value_i64); /*0.4*/
    }
    else if (V_type == pdef::proto::nbt::Type::Float) { /*8.5*/
      WRITE_OR_BAIL(writeFloatBE, (float)obj.value_f32); /*0.4*/
    }
    else if (V_type == pdef::proto::nbt::Type::Double) { /*8.5*/
      WRITE_OR_BAIL(writeDoubleBE, (double)obj.value_f64); /*0.4*/
    }
    else if (V_type == pdef::proto::nbt::Type::ByteArray) { /*8.5*/
      WRITE_OR_BAIL(writeIntBE, (int32_t)obj.value_byteArray.size()); /*1.4*/
      for (const auto &v3 : obj.value_byteArray) { /*3.1*/
        WRITE_OR_BAIL(writeByte, (int8_t)v3); /*0.4*/
      }
    }
    else if (V_type == pdef::proto::nbt::Type::String) { /*8.5*/
      WRITE_OR_BAIL(writeUShortBE, (uint16_t)obj.value_shortString.length());
      WRITE_OR_BAIL(writeString, obj.value_shortString); /*value_shortString: pstring*/ /*4.2*/
    }
    else if (V_type == pdef::proto::nbt::Type::List) { /*8.5*/
      pdef::proto::encode::list(stream, *obj.value_list); /*list*/ /*4.5*/
    }
    else if (V_type == pdef::proto::nbt::Type::Compound) { /*8.5*/
      for (auto& value_compound_item : obj.value_compound) {
      pdef::proto::encode::nbt(stream, value_compound_item, false);
      }
      stream.writeByte(0); /*value_compound: compound*/ /*4.2*/
    }
    else if (V_type == pdef::proto::nbt::Type::IntArray) { /*8.5*/
      WRITE_OR_BAIL(writeIntBE, (int32_t)obj.value_intArray.size()); /*1.4*/
      for (const auto &v3 : obj.value_intArray) { /*3.1*/
        WRITE_OR_BAIL(writeIntBE, (int32_t)v3); /*0.4*/
      }
    }
    else if (V_type == pdef::proto::nbt::Type::LongArray) { /*8.5*/
      WRITE_OR_BAIL(writeIntBE, (int32_t)obj.value_longArray.size()); /*1.4*/
      for (const auto &v3 : obj.value_longArray) { /*3.1*/
        WRITE_OR_BAIL(writeLongBE, (int64_t)v3); /*0.4*/
      }
    }
    return true;
  }
}

namespace pdef::proto::decode {
bool list(pdef::Stream &stream, pdef::proto::list &obj);
bool nbt(pdef::Stream &stream, pdef::proto::nbt &obj);
  bool list(pdef::Stream &stream, pdef::proto::list &obj) {
    READ_OR_BAIL(readByte, (int8_t&)obj.type); /*7.2*/
    const pdef::proto::list::Type &V_type = obj.type; /*0.7*/
    if (V_type == pdef::proto::list::Type::End) { /*8.5*/
    }
    else if (V_type == pdef::proto::list::Type::Byte) { /*8.5*/
      int32_t value_i8_array_len; READ_OR_BAIL(readIntBE, value_i8_array_len); /*1.5*/
      obj.value_i8_array.resize(value_i8_array_len); /*1.6*/
      for (int i = 0; i < value_i8_array_len; i++) { /*3.3*/
        auto &v3 = obj.value_i8_array[i]; /*3.4*/
        READ_OR_BAIL(readByte, v3); /*0.5*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Short) { /*8.5*/
      int32_t value_i16_array_len; READ_OR_BAIL(readIntBE, value_i16_array_len); /*1.5*/
      obj.value_i16_array.resize(value_i16_array_len); /*1.6*/
      for (int i = 0; i < value_i16_array_len; i++) { /*3.3*/
        auto &v3 = obj.value_i16_array[i]; /*3.4*/
        READ_OR_BAIL(readShortBE, v3); /*0.5*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Int) { /*8.5*/
      int32_t value_i32_array_len; READ_OR_BAIL(readIntBE, value_i32_array_len); /*1.5*/
      obj.value_i32_array.resize(value_i32_array_len); /*1.6*/
      for (int i = 0; i < value_i32_array_len; i++) { /*3.3*/
        auto &v3 = obj.value_i32_array[i]; /*3.4*/
        READ_OR_BAIL(readIntBE, v3); /*0.5*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Long) { /*8.5*/
      int32_t value_i64_array_len; READ_OR_BAIL(readIntBE, value_i64_array_len); /*1.5*/
      obj.value_i64_array.resize(value_i64_array_len); /*1.6*/
      for (int i = 0; i < value_i64_array_len; i++) { /*3.3*/
        auto &v3 = obj.value_i64_array[i]; /*3.4*/
        READ_OR_BAIL(readLongBE, v3); /*0.5*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Float) { /*8.5*/
      int32_t value_f32_array_len; READ_OR_BAIL(readIntBE, value_f32_array_len); /*1.5*/
      obj.value_f32_array.resize(value_f32_array_len); /*1.6*/
      for (int i = 0; i < value_f32_array_len; i++) { /*3.3*/
        auto &v3 = obj.value_f32_array[i]; /*3.4*/
        READ_OR_BAIL(readFloatBE, v3); /*0.5*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Double) { /*8.5*/
      int32_t value_f64_array_len; READ_OR_BAIL(readIntBE, value_f64_array_len); /*1.5*/
      obj.value_f64_array.resize(value_f64_array_len); /*1.6*/
      for (int i = 0; i < value_f64_array_len; i++) { /*3.3*/
        auto &v3 = obj.value_f64_array[i]; /*3.4*/
        READ_OR_BAIL(readDoubleBE, v3); /*0.5*/
      }
    }
    else if (V_type == pdef::proto::list::Type::ByteArray) { /*8.5*/
      int32_t value_byteArray_array_len; READ_OR_BAIL(readIntBE, value_byteArray_array_len); /*1.5*/
      obj.value_byteArray_array.resize(value_byteArray_array_len); /*1.6*/
      for (int i = 0; i < value_byteArray_array_len; i++) { /*3.3*/
        auto &v3 = obj.value_byteArray_array[i]; /*3.4*/
        int32_t _len; READ_OR_BAIL(readIntBE, _len); /*1.5*/
        v3.resize(_len); /*1.6*/
        for (int i = 0; i < _len; i++) { /*3.3*/
          auto &v4 = v3[i]; /*3.4*/
          READ_OR_BAIL(readByte, v4); /*0.5*/
        }
      }
    }
    else if (V_type == pdef::proto::list::Type::String) { /*8.5*/
      int32_t value_shortString_array_len; READ_OR_BAIL(readIntBE, value_shortString_array_len); /*1.5*/
      obj.value_shortString_array.resize(value_shortString_array_len); /*1.6*/
      for (int i = 0; i < value_shortString_array_len; i++) { /*3.3*/
        auto &v3 = obj.value_shortString_array[i]; /*3.4*/
        uint16_t _strlen; READ_OR_BAIL(readUShortBE, _strlen);
        if (!stream.readString(v3, _strlen)) return false; /*: pstring*/ /*4.3*/
      }
    }
    else if (V_type == pdef::proto::list::Type::List) { /*8.5*/
      int32_t value_list_array_len; READ_OR_BAIL(readIntBE, value_list_array_len); /*1.5*/
      obj.value_list_array.resize(value_list_array_len); /*1.6*/
      for (int i = 0; i < value_list_array_len; i++) { /*3.3*/
        auto &v3 = obj.value_list_array[i]; /*3.4*/
        pdef::proto::decode::list(stream, v3); /*v3*/ /*4.6*/
      }
    }
    else if (V_type == pdef::proto::list::Type::Compound) { /*8.5*/
      int32_t value_compound_array_len; READ_OR_BAIL(readIntBE, value_compound_array_len); /*1.5*/
      obj.value_compound_array.resize(value_compound_array_len); /*1.6*/
      for (int i = 0; i < value_compound_array_len; i++) { /*3.3*/
        auto &v3 = obj.value_compound_array[i]; /*3.4*/
        while (stream.peekByte() != -1) {
        if (stream.peekByte() == 0) {
        stream.readIndex++;
        break;
        }
        pdef::proto::nbt _item;
        pdef::proto::decode::nbt(stream, _item);
        v3.push_back(std::move(_item));
        } /*: compound*/ /*4.3*/
      }
    }
    else if (V_type == pdef::proto::list::Type::IntArray) { /*8.5*/
      int32_t value_intArray_array_len; READ_OR_BAIL(readIntBE, value_intArray_array_len); /*1.5*/
      obj.value_intArray_array.resize(value_intArray_array_len); /*1.6*/
      for (int i = 0; i < value_intArray_array_len; i++) { /*3.3*/
        auto &v3 = obj.value_intArray_array[i]; /*3.4*/
        int32_t _len; READ_OR_BAIL(readIntBE, _len); /*1.5*/
        v3.resize(_len); /*1.6*/
        for (int i = 0; i < _len; i++) { /*3.3*/
          auto &v4 = v3[i]; /*3.4*/
          READ_OR_BAIL(readIntBE, v4); /*0.5*/
        }
      }
    }
    else if (V_type == pdef::proto::list::Type::LongArray) { /*8.5*/
      int32_t value_longArray_array_len; READ_OR_BAIL(readIntBE, value_longArray_array_len); /*1.5*/
      obj.value_longArray_array.resize(value_longArray_array_len); /*1.6*/
      for (int i = 0; i < value_longArray_array_len; i++) { /*3.3*/
        auto &v3 = obj.value_longArray_array[i]; /*3.4*/
        int32_t _len; READ_OR_BAIL(readIntBE, _len); /*1.5*/
        v3.resize(_len); /*1.6*/
        for (int i = 0; i < _len; i++) { /*3.3*/
          auto &v4 = v3[i]; /*3.4*/
          READ_OR_BAIL(readLongBE, v4); /*0.5*/
        }
      }
    }
    return true;
  }
  bool nbt(pdef::Stream &stream, pdef::proto::nbt &obj) {
    READ_OR_BAIL(readByte, (int8_t&)obj.type); /*7.2*/
    const pdef::proto::nbt::Type &V_type = obj.type; /*0.7*/
    uint16_t name_strlen; READ_OR_BAIL(readUShortBE, name_strlen);
    if (!stream.readString(obj.name, name_strlen)) return false; /*name: pstring*/ /*4.3*/
    if (V_type == pdef::proto::nbt::Type::End) { /*8.5*/
    }
    else if (V_type == pdef::proto::nbt::Type::Byte) { /*8.5*/
      READ_OR_BAIL(readByte, obj.value_i8); /*0.5*/
    }
    else if (V_type == pdef::proto::nbt::Type::Short) { /*8.5*/
      READ_OR_BAIL(readShortBE, obj.value_i16); /*0.5*/
    }
    else if (V_type == pdef::proto::nbt::Type::Int) { /*8.5*/
      READ_OR_BAIL(readIntBE, obj.value_i32); /*0.5*/
    }
    else if (V_type == pdef::proto::nbt::Type::Long) { /*8.5*/
      READ_OR_BAIL(readLongBE, obj.value_i64); /*0.5*/
    }
    else if (V_type == pdef::proto::nbt::Type::Float) { /*8.5*/
      READ_OR_BAIL(readFloatBE, obj.value_f32); /*0.5*/
    }
    else if (V_type == pdef::proto::nbt::Type::Double) { /*8.5*/
      READ_OR_BAIL(readDoubleBE, obj.value_f64); /*0.5*/
    }
    else if (V_type == pdef::proto::nbt::Type::ByteArray) { /*8.5*/
      int32_t value_byteArray_len; READ_OR_BAIL(readIntBE, value_byteArray_len); /*1.5*/
      obj.value_byteArray.resize(value_byteArray_len); /*1.6*/
      for (int i = 0; i < value_byteArray_len; i++) { /*3.3*/
        auto &v3 = obj.value_byteArray[i]; /*3.4*/
        READ_OR_BAIL(readByte, v3); /*0.5*/
      }
    }
    else if (V_type == pdef::proto::nbt::Type::String) { /*8.5*/
      uint16_t value_shortString_strlen; READ_OR_BAIL(readUShortBE, value_shortString_strlen);
      if (!stream.readString(obj.value_shortString, value_shortString_strlen)) return false; /*value_shortString: pstring*/ /*4.3*/
    }
    else if (V_type == pdef::proto::nbt::Type::List) { /*8.5*/
      obj.value_list.reset(new pdef::proto::list{}); pdef::proto::decode::list(stream, *obj.value_list); /*obj*/ /*4.6*/
    }
    else if (V_type == pdef::proto::nbt::Type::Compound) { /*8.5*/
      while (stream.peekByte() != -1) {
      if (stream.peekByte() == 0) {
      stream.readIndex++;
      break;
      }
      pdef::proto::nbt value_compound_item;
      pdef::proto::decode::nbt(stream, value_compound_item);
      obj.value_compound.push_back(std::move(value_compound_item));
      } /*value_compound: compound*/ /*4.3*/
    }
    else if (V_type == pdef::proto::nbt::Type::IntArray) { /*8.5*/
      int32_t value_intArray_len; READ_OR_BAIL(readIntBE, value_intArray_len); /*1.5*/
      obj.value_intArray.resize(value_intArray_len); /*1.6*/
      for (int i = 0; i < value_intArray_len; i++) { /*3.3*/
        auto &v3 = obj.value_intArray[i]; /*3.4*/
        READ_OR_BAIL(readIntBE, v3); /*0.5*/
      }
    }
    else if (V_type == pdef::proto::nbt::Type::LongArray) { /*8.5*/
      int32_t value_longArray_len; READ_OR_BAIL(readIntBE, value_longArray_len); /*1.5*/
      obj.value_longArray.resize(value_longArray_len); /*1.6*/
      for (int i = 0; i < value_longArray_len; i++) { /*3.3*/
        auto &v3 = obj.value_longArray[i]; /*3.4*/
        READ_OR_BAIL(readLongBE, v3); /*0.5*/
      }
    }
    return true;
  }
}

namespace pdef::proto::toJSON {
bool list(pdef::Stream &stream, const pdef::proto::list &obj);
bool nbt(pdef::Stream &stream, const pdef::proto::nbt &obj);
  bool list(pdef::Stream &stream, const pdef::proto::list &obj) {
    PDEF_JSON_putToken_OR_BAIL("{");
    const pdef::proto::list::Type &V_type = obj.type; /*0.3*/
    PDEF_JSON_putInt_OR_BAIL(type, (int64_t)(int8_t&)obj.type); /*J7.1*/
    if (V_type == pdef::proto::list::Type::End) { /*8.5*/
    }
    else if (V_type == pdef::proto::list::Type::Byte) { /*8.5*/
      PDEF_JSON_putStartArr_OR_BAIL(value_i8_array); /*J3.1*/
      for (const auto &v3 : obj.value_i8_array) { /*3.1*/
        PDEF_JSON_putIntAnon_OR_BAIL((int64_t)v3); /*J0.4*/
      }
      PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
    }
    else if (V_type == pdef::proto::list::Type::Short) { /*8.5*/
      PDEF_JSON_putStartArr_OR_BAIL(value_i16_array); /*J3.1*/
      for (const auto &v3 : obj.value_i16_array) { /*3.1*/
        PDEF_JSON_putIntAnon_OR_BAIL((int64_t)v3); /*J0.4*/
      }
      PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
    }
    else if (V_type == pdef::proto::list::Type::Int) { /*8.5*/
      PDEF_JSON_putStartArr_OR_BAIL(value_i32_array); /*J3.1*/
      for (const auto &v3 : obj.value_i32_array) { /*3.1*/
        PDEF_JSON_putIntAnon_OR_BAIL((int64_t)v3); /*J0.4*/
      }
      PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
    }
    else if (V_type == pdef::proto::list::Type::Long) { /*8.5*/
      PDEF_JSON_putStartArr_OR_BAIL(value_i64_array); /*J3.1*/
      for (const auto &v3 : obj.value_i64_array) { /*3.1*/
        PDEF_JSON_putIntAnon_OR_BAIL((int64_t)v3); /*J0.4*/
      }
      PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
    }
    else if (V_type == pdef::proto::list::Type::Float) { /*8.5*/
      PDEF_JSON_putStartArr_OR_BAIL(value_f32_array); /*J3.1*/
      for (const auto &v3 : obj.value_f32_array) { /*3.1*/
        PDEF_JSON_putNumberAnon_OR_BAIL((double)v3); /*J0.4*/
      }
      PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
    }
    else if (V_type == pdef::proto::list::Type::Double) { /*8.5*/
      PDEF_JSON_putStartArr_OR_BAIL(value_f64_array); /*J3.1*/
      for (const auto &v3 : obj.value_f64_array) { /*3.1*/
        PDEF_JSON_putNumberAnon_OR_BAIL((double)v3); /*J0.4*/
      }
      PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
    }
    else if (V_type == pdef::proto::list::Type::ByteArray) { /*8.5*/
      PDEF_JSON_putStartArr_OR_BAIL(value_byteArray_array); /*J3.1*/
      for (const auto &v3 : obj.value_byteArray_array) { /*3.1*/
        PDEF_JSON_putToken_OR_BAIL("["); /*J3.1*/
        for (const auto &v4 : v3) { /*3.1*/
          PDEF_JSON_putIntAnon_OR_BAIL((int64_t)v4); /*J0.4*/
        }
        PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
      }
      PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
    }
    else if (V_type == pdef::proto::list::Type::String) { /*8.5*/
      PDEF_JSON_putStartArr_OR_BAIL(value_shortString_array); /*J3.1*/
      for (const auto &v3 : obj.value_shortString_array) { /*3.1*/
        PDEF_JSON_putStringAnon_OR_BAIL(v3) /*: pstring*/ /*J4.9*/
      }
      PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
    }
    else if (V_type == pdef::proto::list::Type::List) { /*8.5*/
      PDEF_JSON_putStartArr_OR_BAIL(value_list_array); /*J3.1*/
      for (const auto &v3 : obj.value_list_array) { /*3.1*/
      PDEF_JSON_putToken_OR_BAIL("[");  pdef::proto::toJSON::list(stream, v3); PDEF_JSON_putToken_OR_BAIL(","); /*list*/ /*4.5*/
      }
      PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
    }
    else if (V_type == pdef::proto::list::Type::Compound) { /*8.5*/
      PDEF_JSON_putStartArr_OR_BAIL(value_compound_array); /*J3.1*/
      for (const auto &v3 : obj.value_compound_array) { /*3.1*/
        PDEF_JSON_putToken_OR_BAIL("[");
        for (auto& _item : v3) {
        pdef::proto::toJSON::nbt(stream, _item); PDEF_JSON_putToken_OR_BAIL(",");
        }
        PDEF_JSON_putEndArr_OR_BAIL; /*: compound*/ /*J4.9*/
      }
      PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
    }
    else if (V_type == pdef::proto::list::Type::IntArray) { /*8.5*/
      PDEF_JSON_putStartArr_OR_BAIL(value_intArray_array); /*J3.1*/
      for (const auto &v3 : obj.value_intArray_array) { /*3.1*/
        PDEF_JSON_putToken_OR_BAIL("["); /*J3.1*/
        for (const auto &v4 : v3) { /*3.1*/
          PDEF_JSON_putIntAnon_OR_BAIL((int64_t)v4); /*J0.4*/
        }
        PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
      }
      PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
    }
    else if (V_type == pdef::proto::list::Type::LongArray) { /*8.5*/
      PDEF_JSON_putStartArr_OR_BAIL(value_longArray_array); /*J3.1*/
      for (const auto &v3 : obj.value_longArray_array) { /*3.1*/
        PDEF_JSON_putToken_OR_BAIL("["); /*J3.1*/
        for (const auto &v4 : v3) { /*3.1*/
          PDEF_JSON_putIntAnon_OR_BAIL((int64_t)v4); /*J0.4*/
        }
        PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
      }
      PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
    }
    PDEF_JSON_putEndObj_OR_BAIL; PDEF_JSON_FINISH_WRITING; return true;
  }
  bool nbt(pdef::Stream &stream, const pdef::proto::nbt &obj) {
    PDEF_JSON_putToken_OR_BAIL("{");
    const pdef::proto::nbt::Type &V_type = obj.type; /*0.3*/
    PDEF_JSON_putInt_OR_BAIL(type, (int64_t)(int8_t&)obj.type); /*J7.1*/
    PDEF_JSON_putString_OR_BAIL(name, obj.name) /*name: pstring*/ /*J4.9*/
    if (V_type == pdef::proto::nbt::Type::End) { /*8.5*/
    }
    else if (V_type == pdef::proto::nbt::Type::Byte) { /*8.5*/
      PDEF_JSON_putInt_OR_BAIL(value_i8, (int64_t)obj.value_i8); /*J0.4*/
    }
    else if (V_type == pdef::proto::nbt::Type::Short) { /*8.5*/
      PDEF_JSON_putInt_OR_BAIL(value_i16, (int64_t)obj.value_i16); /*J0.4*/
    }
    else if (V_type == pdef::proto::nbt::Type::Int) { /*8.5*/
      PDEF_JSON_putInt_OR_BAIL(value_i32, (int64_t)obj.value_i32); /*J0.4*/
    }
    else if (V_type == pdef::proto::nbt::Type::Long) { /*8.5*/
      PDEF_JSON_putInt_OR_BAIL(value_i64, (int64_t)obj.value_i64); /*J0.4*/
    }
    else if (V_type == pdef::proto::nbt::Type::Float) { /*8.5*/
      PDEF_JSON_putNumber_OR_BAIL(value_f32, (double)obj.value_f32); /*J0.4*/
    }
    else if (V_type == pdef::proto::nbt::Type::Double) { /*8.5*/
      PDEF_JSON_putNumber_OR_BAIL(value_f64, (double)obj.value_f64); /*J0.4*/
    }
    else if (V_type == pdef::proto::nbt::Type::ByteArray) { /*8.5*/
      PDEF_JSON_putStartArr_OR_BAIL(value_byteArray); /*J3.1*/
      for (const auto &v3 : obj.value_byteArray) { /*3.1*/
        PDEF_JSON_putIntAnon_OR_BAIL((int64_t)v3); /*J0.4*/
      }
      PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
    }
    else if (V_type == pdef::proto::nbt::Type::String) { /*8.5*/
      PDEF_JSON_putString_OR_BAIL(value_shortString, obj.value_shortString) /*value_shortString: pstring*/ /*J4.9*/
    }
    else if (V_type == pdef::proto::nbt::Type::List) { /*8.5*/
    PDEF_JSON_putField_OR_BAIL(value_list);  pdef::proto::toJSON::list(stream, *obj.value_list); PDEF_JSON_putToken_OR_BAIL(","); /*list*/ /*4.5*/
    }
    else if (V_type == pdef::proto::nbt::Type::Compound) { /*8.5*/
      PDEF_JSON_putStartArr_OR_BAIL(value_compound);
      for (auto& value_compound_item : obj.value_compound) {
      pdef::proto::toJSON::nbt(stream, value_compound_item); PDEF_JSON_putToken_OR_BAIL(",");
      }
      PDEF_JSON_putEndArr_OR_BAIL; /*value_compound: compound*/ /*J4.9*/
    }
    else if (V_type == pdef::proto::nbt::Type::IntArray) { /*8.5*/
      PDEF_JSON_putStartArr_OR_BAIL(value_intArray); /*J3.1*/
      for (const auto &v3 : obj.value_intArray) { /*3.1*/
        PDEF_JSON_putIntAnon_OR_BAIL((int64_t)v3); /*J0.4*/
      }
      PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
    }
    else if (V_type == pdef::proto::nbt::Type::LongArray) { /*8.5*/
      PDEF_JSON_putStartArr_OR_BAIL(value_longArray); /*J3.1*/
      for (const auto &v3 : obj.value_longArray) { /*3.1*/
        PDEF_JSON_putIntAnon_OR_BAIL((int64_t)v3); /*J0.4*/
      }
      PDEF_JSON_putEndArr_OR_BAIL; /*J3.5*/
    }
    PDEF_JSON_putEndObj_OR_BAIL; PDEF_JSON_FINISH_WRITING; return true;
  }
}

#undef WRITE_OR_BAIL
#undef READ_OR_BAIL
#undef EXPECT_OR_BAIL
#undef PDEF_SIZE_DBG
