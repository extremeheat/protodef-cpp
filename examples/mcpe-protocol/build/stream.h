// DO NOT EDIT THIS FILE:
// This file was automatically generated by protodef-cpp
#pragma once
#include <cstring>
#include <string>
#include <vector>
#include <cstdio>
#include <memory>
#define CHECK_BOUNDS(index) if (index > this->length) { return false; }
namespace pdef {
struct BinaryStream {
  unsigned char *buffer;
  int length;
  int writeIndex = 0;
  int readIndex = 0;

  BinaryStream(int length) : length(length) {
    this->buffer = new unsigned char[length];
  }

  BinaryStream(void *buffer, int length) : buffer((unsigned char*)buffer), length(length) { }

  ~BinaryStream() {
    delete[] this->buffer;
  }

  void reserve(int length) {
    if (length > this->length) {
      delete[] this->buffer;
      this->buffer = new unsigned char[length];
      this->length = length;
    }
  }

  // return -1 if EOF, else return the byte at current read index
  int peekByte() {
    if (readIndex >= length) return -1;
    return buffer[readIndex];
  }

  void dumpToStdout() {
    for (int i = 0; i < this->length; i++) {
      printf("%02x ", (unsigned char)this->buffer[i]);
    }
    printf("\n");
  }

  // write in ASCII
  void dumpWrittenStringToStdout() {
    for (int i = 0; i < this->writeIndex; i++) {
      putchar(this->buffer[i]);
    }
    putchar('\n');
  }

  // Varints
  int sizeOfVarInt(int32_t value) {
    if (value < 0) return 10;
    if (value < 0x80) return 1;
    if (value < 0x4000) return 2;
    if (value < 0x200000) return 3;
    if (value < 0x10000000) return 4;
    return 5;
  }
  int sizeOfZigZagVarInt(int32_t value) { return sizeOfVarInt((value << 1) ^ (value >> 31)); }
  int sizeOfVarLong(int64_t value) {
    if (value < 0) return 10;
    if (value < 0x80) return 1;
    if (value < 0x4000) return 2;
    if (value < 0x200000) return 3;
    if (value < 0x10000000) return 4;
    if (value < 0x800000000) return 5;
    if (value < 0x40000000000) return 6;
    if (value < 0x2000000000000) return 7;
    if (value < 0x100000000000000) return 8;
    return 9;
  }
  int sizeOfZigZagVarLong(int64_t value) { return sizeOfVarLong((value << 1) ^ (value >> 63)); }
  int sizeOfVarInt64(int64_t value) { return sizeOfVarLong(value); }

  // Buffer/String
  int sizeOfBuffer(std::vector<unsigned char> &buffer) { return buffer.size(); }
  int sizeOfString(std::string &value) { return value.length(); }
  
  bool writeByte(int8_t value) {
    CHECK_BOUNDS(writeIndex + 1);
    buffer[writeIndex++] = value;
    return true;
  }
  bool writeUByte(uint8_t value) {
    CHECK_BOUNDS(writeIndex + 1);
    buffer[writeIndex++] = value;
    return true;
  }
  bool writeUShortBE(uint16_t value) {
    CHECK_BOUNDS(writeIndex + 2);
    buffer[writeIndex++] = value >> 8;
    buffer[writeIndex++] = value;
    return true;
  }
  bool writeUIntBE(uint32_t value) {
    CHECK_BOUNDS(writeIndex + 4);
    buffer[writeIndex++] = value >> 24;
    buffer[writeIndex++] = value >> 16;
    buffer[writeIndex++] = value >> 8;
    buffer[writeIndex++] = value;
    return true;
  }
  bool writeULongBE(uint64_t value) {
    CHECK_BOUNDS(writeIndex + 8);
    buffer[writeIndex++] = value >> 56;
    buffer[writeIndex++] = value >> 48;
    buffer[writeIndex++] = value >> 40;
    buffer[writeIndex++] = value >> 32;
    buffer[writeIndex++] = value >> 24;
    buffer[writeIndex++] = value >> 16;
    buffer[writeIndex++] = value >> 8;
    buffer[writeIndex++] = value;
    return true;
  }
  bool writeShortBE(int16_t value) {
    return writeUShortBE(value);
  }
  bool writeIntBE(int32_t value) {
    return writeUIntBE(value);
  }
  bool writeLongBE(int64_t value) {
    return writeULongBE(value);
  }
  bool writeFloatBE(float value) {
    return writeUIntBE(*(uint32_t *)&value);
  }
  bool writeDoubleBE(double value) {
    return writeULongBE(*(uint64_t *)&value);
  }
  bool writeUShortLE(uint16_t value) {
    CHECK_BOUNDS(writeIndex + 2);
    memcpy(buffer + writeIndex, &value, 2);
    return true;
  }
  bool writeUIntLE(uint32_t value) {
    CHECK_BOUNDS(writeIndex + 4);
    memcpy(buffer + writeIndex, &value, 4);
    return true;
  }
  bool writeULongLE(uint64_t value) {
    CHECK_BOUNDS(writeIndex + 8);
    memcpy(buffer + writeIndex, &value, 8);
    return true;
  }
  bool writeShortLE(int16_t value) {
    return writeUShortLE(value);
  }
  bool writeIntLE(int32_t value) {
    return writeUIntLE(value);
  }
  bool writeLongLE(int64_t value) {
    return writeULongLE(value);
  }
  bool writeFloatLE(float value) {
    return writeUIntLE(*(uint32_t *)&value);
  }
  bool writeDoubleLE(double value) {
    return writeULongLE(*(uint64_t *)&value);
  }
  bool writeBool(bool value) {
    return writeByte(value ? 1 : 0);
  }
  bool writeCString(const char *value) {
    while (*value != 0) {
      CHECK_BOUNDS(writeIndex + 1);
      buffer[writeIndex++] = *value++;
    }
    return true;
  }
  bool writeString(const std::string &value) {
    CHECK_BOUNDS(writeIndex + value.length());
    memcpy(buffer + writeIndex, value.data(), value.length());
    writeIndex += value.length();
    return true;
  }
  bool writeBuffer(const std::vector<unsigned char> &value) {
    CHECK_BOUNDS(writeIndex + value.size());
    memcpy(buffer + writeIndex, value.data(), value.size());
    writeIndex += value.size();
    return true;
  }
  int writeUnsignedVarInt(uint32_t value) {
    CHECK_BOUNDS(writeIndex + sizeOfVarInt(value));
    int j = 0;
    do {
      uint8_t temp = value & 0b01111111;
      value >>= 7;
      if (value != 0) {
        temp |= 0b10000000;
      }
      buffer[writeIndex++] = temp;
      j++;
    } while (value != 0);
    return j; 
  }
  int writeUnsignedVarInt(int32_t value) {
    return writeUnsignedVarInt((uint32_t&) value);
  }
  int writeUnsignedVarLong(uint64_t value) {
    CHECK_BOUNDS(writeIndex + sizeOfVarInt64(value));
    int j = 0;
    do {
      uint8_t temp = value & 0b01111111;
      value >>= 7;
      if (value != 0) {
        temp |= 0b10000000;
      }
      buffer[writeIndex++] = temp;
      j++;
    } while (value != 0);
    return j;
  }
  int writeUnsignedVarLong(int64_t value) {
    return writeUnsignedVarLong((uint64_t&) value);
  }
  bool writeZigZagVarInt(int32_t value) {
    return writeUnsignedVarInt((value << 1) ^ (value >> 31));
  }
  bool writeZigZagVarLong(int64_t value) {
    return writeUnsignedVarLong((value << 1) ^ (value >> 63));
  }
  bool readUnsignedVarInt(uint32_t &value) {
    value = 0;
    int i = 0;
    while (true) {
      uint8_t b;
      if (!readUByte(b)) return false;
      value |= (b & 0b01111111) << i++ * 7;
      if ((b & 0b10000000) == 0) break;
    }
    return true;
  }
  bool readUnsignedVarInt(int32_t &value) {
    return readUnsignedVarInt((uint32_t&) value);
  }
  bool readUnsignedVarLong(uint64_t &value) {
    value = 0;
    int i = 0;
    while (true) {
      uint8_t b;
      if (!readUByte(b)) return false;
      value |= (b & 0b01111111) << i++ * 7;
      if ((b & 0b10000000) == 0) break;
    }
    return true;
  }
  bool readUnsignedVarLong(int64_t &value) {
    return readUnsignedVarLong((uint64_t&) value);
  }
  bool readZigZagVarInt(int32_t &value) {
    uint32_t temp;
    if (!readUnsignedVarInt(temp)) return false;
    value = (temp >> 1) ^ -((int32_t)temp & 1);
    return true;
  }
  bool readZigZagVarLong(int64_t &value) {
    uint64_t temp;
    if (!readUnsignedVarLong(temp)) return false;
    value = (temp >> 1) ^ -((int64_t)temp & 1);
    return true;
  }
  bool readByte(int8_t &value) {
    CHECK_BOUNDS(readIndex + 1);
    value = buffer[readIndex++];
    return true;
  }
  bool readUByte(uint8_t &value) {
    CHECK_BOUNDS(readIndex + 1);
    value = buffer[readIndex++];
    return true;
  }
  bool readUShortBE(uint16_t &value) {
    CHECK_BOUNDS(readIndex + 2);
    value = buffer[readIndex++] << 8;
    value |= buffer[readIndex++];
    return true;
  }
  bool readUIntBE(uint32_t &value) {
    CHECK_BOUNDS(readIndex + 4);
    value = buffer[readIndex++] << 24;
    value |= buffer[readIndex++] << 16;
    value |= buffer[readIndex++] << 8;
    value |= buffer[readIndex++];
    return value;
  }
  bool readULongBE(uint64_t &value) {
    CHECK_BOUNDS(readIndex + 8);
    value = static_cast<uint64_t>(buffer[readIndex++]) << 56LL;
    value |= static_cast<uint64_t>(buffer[readIndex++]) << 48;
    value |= static_cast<uint64_t>(buffer[readIndex++]) << 40;
    value |= static_cast<uint64_t>(buffer[readIndex++]) << 32;
    value |= static_cast<uint64_t>(buffer[readIndex++]) << 24;
    value |= static_cast<uint64_t>(buffer[readIndex++]) << 16;
    value |= static_cast<uint64_t>(buffer[readIndex++]) << 8;
    value |= static_cast<uint64_t>(buffer[readIndex++]);
    return true;
  }
  bool readShortBE(int16_t &value) {
    return readUShortBE((uint16_t&) value);
  }
  bool readIntBE(int32_t &value) {
    return readUIntBE((uint32_t&) value);
  }
  bool readLongBE(int64_t &value) {
    return readULongBE((uint64_t&) value);
  }
  bool readFloatBE(float &value) {
    return readUIntBE(*(uint32_t*)&value);
  }
  bool readDoubleBE(double &value) {
    return readULongBE(*(uint64_t*)&value);
  }
  bool readUShortLE(uint16_t &value) {
    CHECK_BOUNDS(readIndex + 2);
    memcpy(&value, buffer + readIndex, 2);
    readIndex += 2;
    return true;
  }
  bool readUIntLE(uint32_t &value) {
    CHECK_BOUNDS(readIndex + 4);
    memcpy(&value, buffer + readIndex, 4);
    readIndex += 4;
    return true;
  }
  bool readULongLE(uint64_t &value) {
    CHECK_BOUNDS(readIndex + 8);
    memcpy(&value, buffer + readIndex, 8);
    readIndex += 8;
    return true;
  }
  bool readShortLE(int16_t &value) {
    return readUShortLE((uint16_t&) value);
  }
  bool readIntLE(int32_t &value) {
    return readUIntLE((uint32_t&) value);
  }
  bool readLongLE(int64_t &value) {
    return readULongLE((uint64_t&) value);
  }
  bool readFloatLE(float &value) {
    CHECK_BOUNDS(readIndex + 4);
    memcpy(&value, buffer + readIndex, 4);
    readIndex += 4;
    return true;
  }
  double readDoubleLE(double &value) {
    CHECK_BOUNDS(readIndex + 8);
    memcpy(&value, buffer + readIndex, 8);
    readIndex += 8;
    return true;
  }
  bool readBool(bool &value) {
    CHECK_BOUNDS(readIndex + 1);
    value = buffer[readIndex++] != 0;
    return true;
  }
  bool readCString(std::string &value) {
    while (true) {
      int8_t c;
      if (!readByte(c)) return false;
      if (c == 0) break;
      value += c;
    }
    return true;
  }
  bool readString(std::string &value, int length) {
    CHECK_BOUNDS(readIndex + length);
    value = std::string(buffer + readIndex, buffer + readIndex + length);
    readIndex += length;
    return true;
  }
  bool readBuffer(std::vector<unsigned char> &value, int length) {
    CHECK_BOUNDS(readIndex + length);
    value = std::vector<unsigned char>(buffer + readIndex, buffer + readIndex + length);
    readIndex += length;
    return true;
  }

  // ASCII
  int sizeOfUnsignedLongInAsciiDigits(uint64_t value) {
    int i = 0;
    do {
      value /= 10;
      i++;
    } while (value != 0);
    return i;
  }
  // write a integer as a string of ascii character digits
  bool writeUnsignedLongInAsciiDigits(uint64_t value) {
    CHECK_BOUNDS(writeIndex + 30);
    char buf[32];
    int i = 0;
    do {
      buf[i++] = value % 10 + '0';
      value /= 10;
    } while (value != 0);
    while (i > 0) {
      buffer[writeIndex++] = buf[--i];
    }
    return true;
  }
  // read an integer from a string of ascii character digits
  bool readUnsignedLongInAsciiDigits(char *str, int len, uint64_t &value) {
    value = 0;
    for (int i = 0; i < len; i++) {
      if (str[i] < '0' || str[i] > '9') return false;
      value = value * 10 + str[i] - '0';
    }
    return true;
  }
  // This has to account for the sign!
  int sizeOfSignedLongInAsciiDigits(int64_t value) {
    int i = 0;
    bool negative = value < 0;
    if (negative) value = -value;
    do {
      value /= 10;
      i++;
    } while (value != 0);
    if (negative) i++;
    return i;
  }
  // This has to write the sign!
  bool writeSignedLongInAsciiDigits(int64_t value) {
    CHECK_BOUNDS(writeIndex + sizeOfSignedLongInAsciiDigits(value));
    char buf[64];
    int i = 0;
    bool negative = value < 0;
    if (negative) value = -value;
    do {
      buf[i++] = value % 10 + '0';
      value /= 10;
    } while (value != 0);
    if (negative) buf[i++] = '-';
    while (i > 0) {
      buffer[writeIndex++] = buf[--i];
    }
    return true;
  }
  // This has to read the sign!
  bool readSignedLongInAsciiDigits(char *str, int len, int64_t &value) {
    value = 0;
    bool negative = false;
    for (int i = 0; i < len; i++) {
      if (str[i] == '-') {
        negative = true;
        continue;
      }
      if (str[i] < '0' || str[i] > '9') return false;
      value = value * 10 + str[i] - '0';
    }
    if (negative) value = -value;
    return true;
  }
  inline void _reverse(char *str, int len) {
    int i = 0, j = len - 1;
    char temp;
    while (i < j) {
      temp = str[i];
      str[i] = str[j];
      str[j] = temp;
      i++;
      j--;
    }
  }
  bool writeDoubleInAsciiDigits(double num, int precision = 4) {
    CHECK_BOUNDS(writeIndex + 24);
    // Allocate memory for the temporary string
    char str[26];
    // Handle negative numbers
    int sign = num < 0 ? -1 : 1;
    num = num * sign;
    // Initialize the index and the size of the string
    int i = 0;
    // Convert the integer part of the number
    long long int_part = (long long)num;
    do {
      str[i++] = (int_part % 10) + '0';
      int_part /= 10;
    } while (int_part > 0);
    // Reverse the integer part of the string
    _reverse(str, i);
    // Add the decimal point if needed
    if (precision > 0) {
      str[i++] = '.';
    }
    // Convert the fractional part of the number
    double frac_part = num - (long long)num;
    for (int j = 0; j < precision; j++) {
      frac_part *= 10;
      str[i++] = ((long long)frac_part % 10) + '0';
      frac_part -= (long long)frac_part;
    }
    // Add the sign if needed
    if (sign == -1) {
      for (int j = i; j >= 0; j--) {
        str[j + 1] = str[j];
      }
      str[0] = '-';
      i++;
    }
    // Remove trailing zeroes
    while (str[i - 1] == '0') {
      i--;
    }
    // If the last character is a decimal point, remove it
    if (str[i - 1] == '.') {
      i--;
    }
    // Write the string to the buffer
    memcpy(buffer + writeIndex, str, i);
    writeIndex += i;
    return true;
  }
  // A function to check if a character is a digit
  inline bool _is_digit(char c) {
    return c >= '0' && c <= '9';
  }
  // A function to convert a string to a double
  bool readDoubleInAsciiDigits(double &value) {
    // Initialize the result, the sign, the exponent and the decimal point flag
    double result = 0.0;
    int sign = 1, exp = 0;
    bool decimal = false;
    // Skip any leading whitespace
    while (buffer[readIndex] == ' ' || buffer[readIndex] == '\t' || buffer[readIndex] == '\n') {
      readIndex++;
    }
    // Handle the sign if present
    if (buffer[readIndex] == '-') {
      sign = -1;
      readIndex++;
    } else if (buffer[readIndex] == '+') {
      readIndex++;
    }
    // Convert the string to a double
    while (buffer[readIndex] != '\0') {
      // If the character is a digit, add it to the result
      if (_is_digit(buffer[readIndex])) {
        result = result * 10 + (buffer[readIndex] - '0');
        if (decimal) {
          exp++; // If the decimal point flag is set, increase the exponent
        }
      } else if (buffer[readIndex] == '.') {
        // If the character is a decimal point, set the flag
        if (decimal) {
          return 0.0; // Invalid input, return zero
        } else {
          decimal = true;
        }
      } else {
        break; // If the character is anything else, break the loop
      }
      readIndex++;
    }
    // Divide the result by 10^exp to get the fractional part
    while (exp > 0) {
      result /= 10;
      exp--;
    }
    // Multiply the result by the sign to get the correct sign
    result *= sign;
    return result;
  }
  // This is just a helper when writing JSON ; remove a trailing comma if we wrote one
  bool jsonPopIfWroteTrailingComma() {
    if (writeIndex > 0 && buffer[writeIndex - 1] == ',') {
      writeIndex--;
    }
    return true;
  }
};

template <typename T, typename Deleter = std::default_delete<T>>
class Optional {
 public:
  Optional() = default;
  Optional(T* ptr) : ptr_(ptr) {}
  Optional(T* ptr, const Deleter& deleter) : ptr_(ptr), deleter_(deleter) {}

  ~Optional() { deleter_(ptr_); }

  Optional(const Optional& other) = delete;

  Optional(Optional&& other) noexcept
      : ptr_(other.release()), deleter_(other.deleter_) {}

  Optional(T val) {
    // new heap allocated value from stack value
    ptr_ = new T(val);
  }
  
  // generalized move ctor
  template <typename U, typename E>
  Optional(Optional<U, E>&& other) noexcept
      : ptr_(other.release()), deleter_(std::forward<E>(other.get_deleter())) {}

  Optional& operator=(const Optional& other) = delete;

  Optional& operator=(Optional&& other) noexcept {
    Optional(std::move(other)).swap(*this);
    return *this;
  }

  // Assignment op to move from stack value -> new heap allocated value
  Optional& operator=(T val) {
    Optional(std::move(val)).swap(*this);
    return *this;
  }

  void reset(T* ptr) noexcept {
    deleter_(ptr_);
    ptr_ = ptr;
  }

  T* release() noexcept {
    auto old_ptr = ptr_;
    ptr_ = nullptr;
    return old_ptr;
  }

  void swap(Optional& other) noexcept {
    using std::swap;
    swap(ptr_, other.ptr_);
  }

  T& operator*() const noexcept { return *ptr_; }
  T* operator->() const noexcept { return ptr_; }
  T* get() const noexcept { return ptr_; }
  Deleter get_deleter() const noexcept { return deleter_; }
  explicit operator bool() const { return ptr_ != nullptr; }
  // Overload the logical NOT operator
  bool operator!() const { 
    return !static_cast<bool>(*this); // Delegate to the existing bool operator
  }

 private:
  T* ptr_ = nullptr;
  Deleter deleter_ = Deleter();
};

using Stream = BinaryStream;
}

#undef CHECK_BOUNDS